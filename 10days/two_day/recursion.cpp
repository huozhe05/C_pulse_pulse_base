//
// Created by fly on 2021/8/27.
//

/**
 * 理解递归出口，因子，堆栈的角度
 *
 * https://blog.csdn.net/sinat_38052999/article/details/73303111?spm=1001.2014.3001.5501
 * 案例：阶乘、斐波那契数列、汉诺塔、杨辉三角的存取、字符串回文判断、字符串全排列、二分查找、树的深度求解在内的八个经典问题。
 *
 * 递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。
 * 特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在
 * 格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。
 *
 * 三要素：明确递归终止条件；给出递归终止时的处理；提取重复的逻辑，缩小问题规模
 *
 * **/

// 模型一
void recursion(大规模)
{
    if (end_condition) // 明确终止条件
    {
        end;
    }
    else // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题
    {
        sovle; //递去
        recursion(小规模) // 递到最深处后，不断地归来
    }
}

// 模型二
void recursion(大规模)
{
    if (end_condition)
    {
        end;
    }
    else // 先将问题全部描述展开，再由尽头“返回”依次解决每一步中剩余部分的问题
    {
        recursion();
        sovle;
    }
}



/**
 * 递归与循环可以相互转换
 * 把递归转换为循环需要：建立“堆栈”来保存数据， 树的三种非递归遍历 *
 * **/


#include <iostream>

int main()
{
    return 0;
}